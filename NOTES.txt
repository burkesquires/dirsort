[x] Add regular expressions of things to erase:
    \[.*?\]
    \(.*?\)
    \d\d\dx\d\d\d
    s\d{1,2}[ex]{1,2}
    \d+
    DVD, BDRip, DVDRip, XviD, x264, h264, aac, MP3, OVA, OAV, episode, season ...

[ ] Add prefixes to directories when auto-created

[ ] Add parameters:
.    -s simulate
    -d also do dir-dir comparisons (to merge duplicates)
.    -y non interactive. accept defaults
.    -f similarity threshold (default:50%)
    -m PREFIX make directory structure, starting with optional PREFIX (don't skip file-file comparisons)

Remove file from list of target alternatives once it has been moved,
but not before (in case the first choice is not the correct one).

[x] Accept several input paths at once.


Algorithm:
0) sort:
	take lowercase basename
	remove extensions and regex matches
	substitute all separators, and split
	calculate similarity factor = number of common parts / number of sum of the parts
	sort to factor

1) simple_move:
	when factor (dir-dir) >= threshold:
	     merge
	     register moved_dir, and threshold

	when factor (dir-file) >= threshold:
	     move file
	     register moved_file, and threshold

2) for remaining files:
        when factor (file-file) >= threshold:
	     if both in sets:
	        skip
	     elif one in set:
	        add other to same set
	        register {file:set}
	     else:
	        add files to new set
	        register both {file:set}

   generate dir_name:
   	    clean shortest name on the set
	    split

	    for p in pieces:
	    	if p.lower() in intersect:
		dirname += p
	    dirname = '_'.join(dirname)
